# 09-1 우선순위 큐의 이해

## 우선순위 큐와 우선순위의 이해
기억하고 있겠지만 앞서 공부한 '큐'의 핵심 연산 두 가지는 다음과 같았다.

* enqueue 큐에 데이터를 삽입하는 행위
* dequeue 큐에서 데이터를 꺼내는 행위

이와 마찬가지로 '우선순위 큐'의 핵심 연산 두 가지도 다음과 같다.

반면 연산의 결과에는 차이가 있다. 큐는 연산의 결과로, 먼저 들어간 데이터가 먼저 나오지만, 우선순위 큐의 연선결과는 다음과 같다.
>들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다.

이렇듯 우선순위 큐에서 중요한 것은 우선순위이다.

## 우선순위 큐의 구현 방법
* 배열을 기반으로 구현하는 방법
* 연결 리스트를 기반으로 구현하는 방법
* 힙(heap)을 이용하는 방법

배열의 경우, 데이터의 우선순위가 높을수록 배열의 앞쪽에 데이터를 위치시킨다. 이렇게 하면 우선순위가 높은 데이터를 반환 및 소멸하는 것이 어려운 일이 아니다. 하지만 여러분도 잘 알다시피 다음과 같은 단점이 따른다.
>데이터를 삽입 및 삭제하는 과정에서 데이터를 한 칸씩 뒤러 밀거나 한 칸씩 앞으로 당기는 연산을 수반해야 한다.

이는 배열의 대표적인 단점이다. 하지만 이보더 더 큰 문제는 다음과 같다.
>삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위의 비교를 진행해야 할 수도 있다.

이는 우선순위가 가장 낮은 데이터를 저장하는 경우에 발생하는 최악의 상황이다. 그렇다면 연결 리스트의 경우는 어떨까? 연결 리스트의 경우, 위에서 말한 배열의 첫 번째 단점은 갖지 않는다. 하지만 두 번째 단점은 연결 리스트에도 존재한다.
>삽입의 위치를 찾기 위해서 첫 번째 노드에서부터 시작해서 마지막 노드에 저장된 데이터와 우선순위의 비교를 진행해야 할 수도 있다.

이는 데이터의 수가 적은 경우 큰 단점이 되지 않을 수 있다. 하지만 데이터의 수가 많아지면, 그래서 연결된 노드의 수가 많아지면, 노드의 수에 비례해서 성능을 저하시키는 주원인이 된다. 그래서 우선순위 큐는 단순 배열도 연결 리스트도 아닌 '힙'이라는 자료구조를 이용해서 구현하는 것이 일반적이다.

## 힙(Heap)의 소개
>힙은 '이진트리'이되 '완전 이진 트리'이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.

위에서 말하는 '값'은 말 그대로 '값'이 될 수도 있고, 우선순위 큐에서 말하는 '우선순위'가 될 수도 있다.

위와 같이 루트 노드로 올라갈 수록 저장된 값이 커지는 완전 이진 트리를 가리켜 '최대 힙(max heap)'이라 한다. 반면 다음 그림과 같이 루트 노드로 올라갈수록 저장된 값이 작아지는 완전 이진 트리를 가리켜 '최소 힙(min heap)'이라 한다.

# 09-2 힙의 구현과 우선순위 큐의 완성
힙의 구현은 곧 우선순위 큐의 완성으로 이어진다. 따라서 힙과 우선순위 큐를 동일하게 인식하는 경향이 매우 강하다. 하지만 이는 정확하지 않은 것이니, 우선순위 큐와 힙을 어느 정도는 구분할 수 있으면 좋겠다. 힙은 우선순위 큐의 구현에 딱 어울리는, 완전 이진 트리의 일종이라는 사실을 기억하기 바란다.

## 힙에서의 데이터 저장과정
<img src="../images/그림 09-4.png" title="[그림 09-4: 데이터 추가 직전의 힙]" alt="[그림 09-4: 데이터 추가 직전의 힙]"></img>  
  
위 그림에 쓰여있는 숫자를 데이터 겸 우선순위라 하자! 그리고 숫자가 작을수록 우선순위가 높다고 가정하자. 그렇다면 위의 그림은 우선순위 관점에서 힙이 맞다! 완전 이진 트리이면서, 어느 위치에서든 다음 식이 성립하기 때문이다.
> 자식 노드 데이터의 우선순위 &leq; 부모 노드 데이터의 우선순위
 
> 새로운 데이터는 우선순위가 제일 낮다는 가정하에서 '마지막 위치'에 저장합니다. 그리고는 부모 노드와 우선순위를 비교해서 위치가 바뀌어야 한다면 바꿔줍니다. 바뀐 다음에도 계속해서 부모 노드와 비교합니다. 제대로 된 위치를 찾을 때까지 말이지요.

이렇듯 데이터의 추가과정은 마지막 위치에 데이터를 두고서 부모 노드와의 비교를 통해 자신의 위치를 찾아가는 매우 단순한 방식이다.

## 힙에서의 데이터 삭제과정
그런데 우선순위 큐의 삭제는 '가장 높은 우선순위의 데이터를 삭제'를 의미하므로, 우리는 힙을 대상으로 다음 내용을 고민해야 한다.
> "힙에서 루트 노드를 어떻게 삭제할 것인가?"

문제는 삭제 후에도 힙의 구조를 유지해야 한다는데 있다.  
즉 우리가 고민해야 할 문제의 본질은 다음과 같다.
> 힙에서 루트 노드를 삭제한 다음에 이 부분을 어떻게 채울 것인가?

> 마지막 노드를 루트 노드의 자리로 옮긴 다음에, 자식 노드와의 비교를 통해서 제자리를 찾아가게 한다.

## 삽입과 삭제의 과정에서 보인 성능의 평가
> 우선순위 큐의 구현에 있어서 단순 배열이나 연결 리스트보다 힙이 더 적합한 이유는 어디에 있는가?

* 배열 기반 데이터 저장의 시간 복잡도 **_O(n)_**
* 배열 기반 데이터 삭제의 시간 복잡도 **_O(1)_**

우선순위가 낮은 데이터를 배열에 저장하는 경우, 배열에 저장된 모든 데이터와의 우선순위 비교과정을 가져야 하므로 데이터 저장의 시간 복잡도는 <strong>_O(n)_</strong>이 되고, 삭제의 과정에서는 맨 앞에 저장된 데이터를 삭제하면 되기 때문에, 이 경우의 시간 복잡도는 <strong>_O(1)_</strong>이 된다.

* 연결 리스트 기반의 데이터 저장의 시간 복잡도 **_O(n)_**
* 연결 리스트 기반의 데이터 삭제의 시간 복잡도 **_O(n)_**

우선순위가 높을수록, 데이터를 연결 리스트의 앞 부분에 배치하는 방식이므로 배열의 경우와 다를 바가 없다. 하지만 힙의 경우는 어떤가? 삽입이나 삭제의 경우 동반되는 비교연산은 주로 부모 노드와 자식 노드 사이에서 일어난다. 그리고 이것이 의미하는 바는 다음과 같다.
> 힙을 기반으로 하면 트리의 높이에 해당하는 수만큼만 비교연산을 진행하면 됩니다.

이는 트리의 높이가 하나 늘어날 때마다 비교연산의 횟수가 하나 증가한다는 뜻이므로, 힙의 성능은 다음과 같이 정리할 수 있다.
* 힙 기반 데이터 저장의 시간 복잡도 _O(log2n)_
* 힙 기반 데이터 삭제의 시간 복잡도 _O(log2n)_

힙은 완전 이진 트리이므로, 힙에 저장할 수 있는 데이터의 수는 트리의 높이가 하나 늘 때마다 두 배씩 증가한다. 때문에 데이터의 수가 두 배 늘 때마다, 비교연산의 횟수는 1회 증가한다.

## 힙의 구현에 어울리는 것은 연결리스트? 아니면 배열?
실제로 힙의 구현은 배열을 기반으로 구현하는 것이 원칙으로 여겨지고 있는데, 그 이유는 다음과 같다.
> 연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막'위치에 추가하는 것이 쉽지 않다.

그래서 힙과 같이, 새로운 노드를 추가한 이훙도 완전 이진 트리를 유지해야 하는 경우에는 연결 리스트가 아닌 배열을 기반으로 트리를 구현해야 한다.
