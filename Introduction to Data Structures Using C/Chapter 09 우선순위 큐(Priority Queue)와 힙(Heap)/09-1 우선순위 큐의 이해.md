# 09-1 우선순위 큐의 이해

## 우선순위 큐와 우선순위의 이해
기억하고 있겠지만 앞서 공부한 '큐'의 핵심 연산 두 가지는 다음과 같았다.

* enqueue&nbsp;&nbsp;&nbsp;&nbsp;큐에 데이터를 삽입하는 행위
* dequeue&nbsp;&nbsp;&nbsp;&nbsp;큐에서 데이터를 꺼내는 행위

이와 마찬가지로 '우선순위 큐'의 핵심 연산 두 가지도 다음과 같다.

반면 연산의 결과에는 차이가 있다. 큐는 연산의 결과로, 먼저 들어간 데이터가 먼저 나오지만, 우선순위 큐의 연선결과는 다음과 같다.
>"들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다."

이렇듯 우선순위 큐에서 중요한 것은 우선순위이다.

## 우선순위 큐의 구현 방법
* 배열을 기반으로 구현하는 방법
* 연결 리스트를 기반으로 구현하는 방법
* 힙(heap)을 이용하는 방법

배열의 경우, 데이터의 우선순위가 높을수록 배열의 앞쪽에 데이터를 위치시킨다. 이렇게 하면 우선순위가 높은 데이터를 반환 및 소멸하는 것이 어려운 일이 아니다. 하지만 여러분도 잘 알다시피 다음과 같은 단점이 따른다.
>"데이터를 삽입 및 삭제하는 과정에서 데이터를 한 칸씩 뒤러 밀거나 한 칸씩 앞으로 당기는 연산을 수반해야 한다."

이는 배열의 대표적인 단점이다. 하지만 이보더 더 큰 문제는 다음과 같다.
>"삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위의 비교를 진행해야 할 수도 있다."

이는 우선순위가 가장 낮은 데이터를 저장하는 경우에 발생하는 최악의 상황이다. 그렇다면 연결 리스트의 경우는 어떨까? 연결 리스트의 경우, 위에서 말한 배열의 첫 번째 단점은 갖지 않는다. 하지만 두 번째 단점은 연결 리스트에도 존재한다.
>"삽입의 위치를 찾기 위해서 첫 번째 노드에서부터 시작해서 마지막 노드에 저장된 데이터와 우선순위의 비교를 진행해야 할 수도 있다."

이는 데이터의 수가 적은 경우 큰 단점이 되지 않을 수 있다. 하지만 데이터의 수가 많아지면, 그래서 연결된 노드의 수가 많아지면, 노드의 수에 비례해서 성능을 저하시키는 주원인이 된다. 그래서 우선순위 큐는 단순 배열도 연결 리스트도 아닌 '힙'이라는 자료구조를 이용해서 구현하는 것이 일반적이다.

## 힙(Heap)의 소개
>"힙은 '이진트리'이되 '완전 이진 트리'이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다."

위에서 말하는 '값'은 말 그대로 '값'이 될 수도 있고, 우선순위 큐에서 말하는 '우선순위'가 될 수도 있다.

위와 같이 루트 노드로 올라갈 수록 저장된 값이 커지는 완전 이진 트리를 가리켜 '최대 힙(max heap)'이라 한다. 반면 다음 그림과 같이 루트 노드로 올라갈수록 저장된 값이 작아지는 완전 이진 트리를 가리켜 '최소 힙(min heap)'이라 한다.

# 09-2 힙의 구현과 우선순위 큐의 완성
힙의 구현은 곧 우선순위 큐의 완성으로 이어진다. 따라서 힙과 우선순위 큐를 동일하게 인식하는 경향이 매우 강하다. 하지만 이는 정확하지 않은 것이니, 우선순위 큐와 힙을 어느 정도는 구분할 수 있으면 좋겠다. 힙은 우선순위 큐의 구현에 딱 어울리는, 완전 이진 트리의 일종이라는 사실을 기억하기 바란다.

## 힙에서의 데이터 저장과정
<img src="../images/그림 09-4.png" title="[그림 09-4: 데이터 추가 직전의 힙]" alt="[그림 09-4: 데이터 추가 직전의 힙]"></img>
위 그림에 쓰여있는 숫자를 데이터 겸 우선순위라 하자! 그리고 숫자가 작을수록 우선순위가 높다고 가정하자. 그렇다면 위의 그림은 우선순위 관점에서 힙이 맞다! 완전 이진 트리이면서, 어느 위치에서든 다음 식이 성립하기 때문이다.
> 자식 노드 데이터의 우선순위 $$<=$$ 부모 노드 데이터의 우선순위
