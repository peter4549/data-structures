# 09-2 힙의 구현과 우선순위 큐의 완성
힙의 구현은 곧 우선순위 큐의 완성으로 이어진다. 따라서 힙과 우선순위 큐를 동일하게 인식하는 경향이 매우 강하다. 하지만 이는 정확하지 않은 것이니, 우선순위 큐와 힙을 어느 정도는 구분할 수 있으면 좋겠다. 힙은 우선순위 큐의 구현에 딱 어울리는, 완전 이진 트리의 일종이라는 사실을 기억하기 바란다.

## 힙에서의 데이터 저장과정
<img src="../images/그림 09-4.png" title="[그림 09-4: 데이터 추가 직전의 힙]" alt="[그림 09-4: 데이터 추가 직전의 힙]"></img>  
  
위 그림에 쓰여있는 숫자를 데이터 겸 우선순위라 하자! 그리고 숫자가 작을수록 우선순위가 높다고 가정하자. 그렇다면 위의 그림은 우선순위 관점에서 힙이 맞다! 완전 이진 트리이면서, 어느 위치에서든 다음 식이 성립하기 때문이다.
> 자식 노드 데이터의 우선순위 $\leq$ 부모 노드 데이터의 우선순위
 
> 새로운 데이터는 우선순위가 제일 낮다는 가정하에서 '마지막 위치'에 저장합니다. 그리고는 부모 노드와 우선순위를 비교해서 위치가 바뀌어야 한다면 바꿔줍니다. 바뀐 다음에도 계속해서 부모 노드와 비교합니다. 제대로 된 위치를 찾을 때까지 말이지요.

이렇듯 데이터의 추가과정은 마지막 위치에 데이터를 두고서 부모 노드와의 비교를 통해 자신의 위치를 찾아가는 매우 단순한 방식이다.

## 힙에서의 데이터 삭제과정
그런데 우선순위 큐의 삭제는 '가장 높은 우선순위의 데이터를 삭제'를 의미하므로, 우리는 힙을 대상으로 다음 내용을 고민해야 한다.
> 힙에서 루트 노드를 어떻게 삭제할 것인가?

문제는 삭제 후에도 힙의 구조를 유지해야 한다는데 있다.  
즉 우리가 고민해야 할 문제의 본질은 다음과 같다.
> 힙에서 루트 노드를 삭제한 다음에 이 부분을 어떻게 채울 것인가?

> 마지막 노드를 루트 노드의 자리로 옮긴 다음에, 자식 노드와의 비교를 통해서 제자리를 찾아가게 한다.

## 삽입과 삭제의 과정에서 보인 성능의 평가
> 우선순위 큐의 구현에 있어서 단순 배열이나 연결 리스트보다 힙이 더 적합한 이유는 어디에 있는가?

* 배열 기반 데이터 저장의 시간 복잡도&emsp; &emsp; $O(n)$
* 배열 기반 데이터 삭제의 시간 복잡도&nbsp; &nbsp; $O(1)$

우선순위가 낮은 데이터를 배열에 저장하는 경우, 배열에 저장된 모든 데이터와의 우선순위 비교과정을 가져야 하므로 데이터 저장의 시간 복잡도는 $O(n)$이 되고, 삭제의 과정에서는 맨 앞에 저장된 데이터를 삭제하면 되기 때문에, 이 경우의 시간 복잡도는 $O(1)$이 된다.

* 연결 리스트 기반의 데이터 저장의 시간 복잡도&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $O(n)$
* 연결 리스트 기반의 데이터 삭제의 시간 복잡도&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $O(n)$

우선순위가 높을수록, 데이터를 연결 리스트의 앞 부분에 배치하는 방식이므로 배열의 경우와 다를 바가 없다. 하지만 힙의 경우는 어떤가? 삽입이나 삭제의 경우 동반되는 비교연산은 주로 부모 노드와 자식 노드 사이에서 일어난다. 그리고 이것이 의미하는 바는 다음과 같다.
> 힙을 기반으로 하면 트리의 높이에 해당하는 수만큼만 비교연산을 진행하면 됩니다.

이는 트리의 높이가 하나 늘어날 때마다 비교연산의 횟수가 하나 증가한다는 뜻이므로, 힙의 성능은 다음과 같이 정리할 수 있다.
* 힙 기반 데이터 저장의 시간 복잡도&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $O(log_2n)$
* 힙 기반 데이터 삭제의 시간 복잡도&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $O(log_2n)$

힙은 완전 이진 트리이므로, 힙에 저장할 수 있는 데이터의 수는 트리의 높이가 하나 늘 때마다 두 배씩 증가한다. 때문에 데이터의 수가 두 배 늘 때마다, 비교연산의 횟수는 1회 증가한다.

## 힙의 구현에 어울리는 것은 연결리스트? 아니면 배열?
실제로 힙의 구현은 배열을 기반으로 구현하는 것이 원칙으로 여겨지고 있는데, 그 이유는 다음과 같다.
> 연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막'위치에 추가하는 것이 쉽지 않다.

그래서 힙과 같이, 새로운 노드를 추가한 이훙도 완전 이진 트리를 유지해야 하는 경우에는 연결 리스트가 아닌 배열을 기반으로 트리를 구현해야 한다.

## 배열을 기반으로 힙을 구현하는데 필요한 지식들
>노드에 고유의 번호를 부여한다. 그리고 그 번호가 각 노드의 데이터가 저장 될 배열의 인덱스 값이 된다.

자! 그럼 배열을 기반으로 힙을 구현하기 위해서 무엇을 더 알아야 할까?
>왼쪽 그리고 오른쪽 자식 노드의 인덱스 값을 얻는 방법, 그리고 부모 노드의 인덱스 값을 얻는 방법

자식 노드의 인덱스 값을 얻는 방법은 데이터의 삭제를 위해서, 부모 노드의 인덱스 값을 얻는 방법은 데이터의 추가를 위해서 필요하다.
* 왼쪽 자식 노드의 인덱스 값 부모 노드의 인덱스 값 $\times$ 2
* 오른쪽 자식 노드의 인덱스 값 부모 노드의 인덱스 값 $\times$ 2 $+$ 1
* 부모 노드의 인덱스 값 자식 노드의 인덱스 값 $\div$ 2

이진 트리는 레벨이 증가함에 따라서 추가할 수 있는 자식 노드의 수가 두 배씩 증가하는 구조다 보니, 2를 나누고 곱하는 방식으로 부모 노드와 자식 노드의 인덱스 값을 구할 수 있다.

## 원리 이해 중심의 힙 구현: 헤더파일의 소개

### SimpleHeap.h
```
#ifndef __SIMPLE_HEAP_H__
#define __SIMPLE_HEAP_H__

#define TRUE		1
#define FALSE		0

#define HEAP_LEN	100

typedef char HData;
typedef int Priority;

typedef struct _heapElem
{
	Priority pr;	// 값이 작을수록 높은 우선순위
	HData data;
} HeapElem;

typedef struct _heap
{
	int numOfData;
	HeapElem heapArr[HEAP_LEN];
} Heap;

void HeapInit(Heap * ph);
int HIsEmpty(Heap * ph);

void HInsert(Heap * ph, HData data, Priority pr);
HData HDelete(Heap * ph);

#endif
```

## 원리 이해 중심의 힙 구현: HDelete 함수에 대한 설명 중심으로
* 힙은 완전 이진 트리이다.
* 힙의 구현은 배열을 기반으로 하며 인덱스가 0인 요소는 비워둔다.
* 따라서 
