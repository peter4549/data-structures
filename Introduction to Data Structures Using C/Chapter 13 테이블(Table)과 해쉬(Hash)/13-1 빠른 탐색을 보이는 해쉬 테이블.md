# 13-1 빠른 탐색을 보이는 해쉬 테이블

## 테이블(Table) 자료구조의 이해

테이블 자료구조의 탐색 연산은 $O(1)의 시간 복잡도

> 저장되는 데이터는 키(key)와 값(value)이 하나의 쌍을 이룬다.

테이블에 저장되는 모든 데이터들은 이를 구분하는 '키'가 있어야 하고, 이 키는 데이터를 구분하는 기준이 되기 때문에 중복이 되어서는 안된다. 테이블에는 키와 관련해서 다음의 조건이 존재한다.

> 키(key)가 존재하지 않는 '값'은 저장할 수 없다. 그리고 모든 키는 중복되지 않는다.

테이블의 핵심은, 키와 값이 하나의 쌍을 이루어 저장되는 데이터의 유형에 있다.

자료구조의 '테이블'은 '사전구조'라고도 불린다. 더불어 '맵(map)'이라 불리기도 한다.

## 배열을 기반으로 하는 테이블

### UnderstandTable.c

```
# include <stdio.h>

typedef struct _empInfo
{
	int empNum;			// 직원의 고유번호
	int age;			// 직원의 나이
} EmpInfo;

int main(void)
{
	EmpInfo empInfoArr[1000];
	EmpInfo ei;
	int eNum;

	printf("사번과 나이 입력: ");
	scanf("%d %d", &(ei.empNum), &(ei.age));
	empInfoArr[ei.empNum] = ei;			// 단번에 저장!

	printf("확인하고픈 직원의 사번 입력: ");
	scanf("%d", &eNum);

	ei = empInfoArr[eNum];		// 단번에 탐색!
	printf("사번 %d, 나이 %d \n", ei.empNum, ei.age);
	return 0;
}
```

다음 조건만 만족한다면 어렇듯 단순한 배열도 테이블, 또는 테이블의 일부라 할 수 있다.

> 키를 결정하였다면, 이를 기반으로 데이터를 단번에 찾을 수 있어야 한다.

테이블에서 의미하는 키는 데이터를 찾는 도구가 되어야 한다.

> 그럼 직원 고유번호의 범위가 100000~999999라면 어떻게 해야 하나요? 위와 같은 방식으로 테이블을 구성하려면 매우 큰 배열이 필요하겠죠?

이러한 문제점은 앞서 보인 테이블의 예에서 테이블의 핵심인 '해쉬'와 관련된 내용이 빠졌기 때문에 등장한 것이다.

## 테이블에 의미를 부여하는 해쉬 함수와 충돌문제

예제에서 보인 테이블과 관련하여 지적한 문제점 두 가지를 정리하면 다음과 같다.

> 직원 고유번호의 범위가 배열의 인덱스 값으로 사용하기에 적당하지 않다.

> 직원 고유번호의 범위를 수용할 수 있는 매우 큰 배열이 필요하다.

이 두 가지 문제를 동시에 해결해주는 것이 바로 '해쉬 함수'이다.

### TableHashFunction.c
```
# include <stdio.h>

typedef struct _empInfo
{
	int empNum;			// 직원의 고유번호
	int age;			// 직원의 나이
} EmpInfo;

int GetHashValue(int empNum)
{
	return empNum % 100;
}

int main(void)
{
	EmpInfo empInfoArr[1000];
	
	EmpInfo emp1 = { 20120003, 42 };
	EmpInfo emp2 = { 20130012, 33 };
	EmpInfo emp3 = { 20170049, 27 };

	EmpInfo r1, r2, r3;

	// 키를 인덱스 값으로 이용해서 저장
	empInfoArr[GetHashValue(emp1.empNum)] = emp1;
	empInfoArr[GetHashValue(emp2.empNum)] = emp2;
	empInfoArr[GetHashValue(emp3.empNum)] = emp3;

	// 키를 인덱스 값으로 이용해서 탐색
	r1 = empInfoArr[GetHashValue(20120003)];
	r2 = empInfoArr[GetHashValue(20130012)];
	r3 = empInfoArr[GetHashValue(20170049)];

	// 탐색 결과 확인
	printf("사번 %d, 나이 %d \n", r1.empNum, r1.age);
	printf("사번 %d, 나이 %d \n", r2.empNum, r2.age);
	printf("사번 %d, 나이 %d \n", r3.empNum, r3.age);
	return 0;
}
```

해쉬 함수는 넓은 범위의 키를 좁은 범위의 키로 변경하는 역할을 한다.

서로 다른 두 개의 키가 해쉬 함수를 통과하였는데, 그 결과가 모두 동일하다. 이러한 상황을 가리켜 '충돌(collision)'이라 하는데, 이러한 충돌은 배열의 길이를 늘리는 등의 방법으로 피해야 할 상황이 아니다.

충돌은 피해야 하는 상황이 아니라 '해결해야 하는 상황'인 것이다.

충돌의 해결방법에 따라서 테이블의 구조가 달라지는 경우가 있을 정도로 충돌의 해결방법은 테이블에 있어서 큰 의미를 갖는다.

## 어느 정도 갖춰진 테이블과 해쉬의 구현의 예
### Person.h
```
#ifndef __PERSON_H__
#define __PERSON_H__

#define STR_LEN 50

typedef struct _person
{
	int ssn;				// 주민등록번호
	char name[STR_LEN];		// 이 름
	char addr[STR_LEN];		// 주 소
} Person;

int GetSSN(Person * p);
void ShowPerInfo(Person * p);
Person * MakePersonData(int ssn, char * name, char * addr);

#endif
```

### Person.c
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Person.h"

int GetSSN(Person * p)
{
	return p->ssn;
}

void ShowPerInfo(Person * p)
{
	printf("주민등록번호: %d \n", p->ssn);
	printf("이름: %s \n", p->name);
	printf("주소: %s \n\n", p->addr);
}

Person * MakePersonData(int ssn, char * name, char * addr)
{
	Person * newP = (Person*)malloc(sizeof(Person));
	newP->ssn = ssn;
	strcpy(newP->name, name);
	strcpy(newP->addr, addr);
	return newP;
}
```

### Slot.h
```
#ifndef __SLOT_H__
#define __SLOT_H__

#include "Person.h"

typedef int Key;
typedef Person * Value;

enum SlotStatus { EMPTY, DELETED, INUSE };

typedef struct _slot
{
	Key key;
	Value val;
	enum SlotStatus status;
} Slot;

#endif
```

슬롯이란 '테이블을 이루는, 데이터를 저장할 수 있는 각각의 공간'을 의미한다.

슬롯의 상태를 나타내는 상수 각각이 의미하는 바는 다음과 같다.

* EMPTY				
