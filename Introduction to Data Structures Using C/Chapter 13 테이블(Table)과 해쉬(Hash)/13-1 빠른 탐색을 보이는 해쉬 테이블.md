# 13-1 빠른 탐색을 보이는 해쉬 테이블

## 테이블(Table) 자료구조의 이해

테이블 자료구조의 탐색 연산은 $O(1)의 시간 복잡도

> 저장되는 데이터는 키(key)와 값(value)이 하나의 쌍을 이룬다.

테이블에 저장되는 모든 데이터들은 이를 구분하는 '키'가 있어야 하고, 이 키는 데이터를 구분하는 기준이 되기 때문에 중복이 되어서는 안된다. 테이블에는 키와 관련해서 다음의 조건이 존재한다.

> 키(key)가 존재하지 않는 '값'은 저장할 수 없다. 그리고 모든 키는 중복되지 않는다.

테이블의 핵심은, 키와 값이 하나의 쌍을 이루어 저장되는 데이터의 유형에 있다.

자료구조의 '테이블'은 '사전구조'라고도 불린다. 더불어 '맵(map)'이라 불리기도 한다.

## 배열을 기반으로 하는 테이블

### UnderstandTable.c

```
# include <stdio.h>

typedef struct _empInfo
{
	int empNum;			// 직원의 고유번호
	int age;			// 직원의 나이
} EmpInfo;

int main(void)
{
	EmpInfo empInfoArr[1000];
	EmpInfo ei;
	int eNum;

	printf("사번과 나이 입력: ");
	scanf("%d %d", &(ei.empNum), &(ei.age));
	empInfoArr[ei.empNum] = ei;			// 단번에 저장!

	printf("확인하고픈 직원의 사번 입력: ");
	scanf("%d", &eNum);

	ei = empInfoArr[eNum];		// 단번에 탐색!
	printf("사번 %d, 나이 %d \n", ei.empNum, ei.age);
	return 0;
}
```

다음 조건만 만족한다면 어렇듯 단순한 배열도 테이블, 또는 테이블의 일부라 할 수 있다.

> 키를 결정하였다면, 이를 기반으로 데이터를 단번에 찾을 수 있어야 한다.

테이블에서 의미하는 키는 데이터를 찾는 도구가 되어야 한다.

> 그럼 직원 고유번호의 범위가 100000~999999라면 어떻게 해야 하나요? 위와 같은 방식으로 테이블을 구성하려면 매우 큰 배열이 필요하겠죠?

이러한 문제점은 앞서 보인 테이블의 예에서 테이블의 핵심인 '해쉬'와 관련된 내용이 빠졌기 때문에 등장한 것이다.

## 테이블에 의미를 부여하는 해쉬 함수와 충돌문제

예제에서 보인 테이블과 관련하여 지적한 문제점 두 가지를 정리하면 다음과 같다.

> 직원 고유번호의 범위가 배열의 인덱스 값으로 사용하기에 적당하지 않다.

> 직원 고유번호의 범위를 수용할 수 있는 매우 큰 배열이 필요하다.

이 두 가지 문제를 동시에 해결해주는 것이 바로 '해쉬 함수'이다.

### TableHashFunction.c
```
```
